{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE TypeApplications #-}

import           Criterion.Main
import           Data.Array.Accelerate         as A
import qualified Data.Array.Accelerate.LLVM.Native
                                               as CPU
import qualified Data.Array.Accelerate.LLVM.PTX
                                               as PTX
import           Prelude                       as P
import qualified System.Random.MWC             as Rng

-- Convert a 'Word64' as generated by a PRNG directly to a @[0, 1]@ 'Float'
-- value.
word64ToFloat :: Exp Word64 -> Exp Float
word64ToFloat n =
  A.fromIntegral n * (1 / A.fromIntegral (maxBound :: Exp Word64))

-- Convert a 'Word64' as generated by a PRNG to a @[0, 1]@ 'Float'
-- value by first casting to a 'Word32'.
word64ToFloat' :: Exp Word64 -> Exp Float
word64ToFloat' n =
  A.fromIntegral n' * (1 / A.fromIntegral (maxBound :: Exp Word32))
  where n' = A.fromIntegral @Word64 @Word32 n

-- | Run the benchmark using the specified @run1@ implementation.
--
-- FIXME: I couldn't get this to type check with @Afunction@ and @AfunctionR@.
benchFor
  :: (  (Acc (Vector Word64) -> Acc (Vector Float))
     -> (Vector Word64 -> Vector Float)
     )
  -> String
  -> Benchmark
benchFor run1 name = bgroup name $ P.map
  (\n -> env (genData n) $ \xs -> bgroup (show n P.++ " Word64 values")
    $ P.map (\(f, fName) -> bench fName (nf f xs)) functions
  )
  [100_000, 1_000_000, 10_000_000, 100_000_000]
 where
  !functions =
    [ (run1 $ A.map word64ToFloat , "Word64 -> Float")
    , (run1 $ A.map word64ToFloat', "Word64 -> Word32 -> Float")
    ]

  -- | Generate @n@ random 'Word64' values.
  genData :: Int -> IO (Vector Word64)
  genData n = Rng.createSystemRandom
    >>= \rng -> fromFunctionM (Z :. n) (const $ Rng.uniform rng)

main :: IO ()
main = defaultMain [benchFor CPU.runN "CPU", benchFor PTX.runN "GPU"]
